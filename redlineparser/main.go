// Description: This program reads the data from the input folder and writes it to parquet files in the output folder. refer to README.md for more info
package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/xitongsys/parquet-go-source/local"
	"github.com/xitongsys/parquet-go/parquet"
	"github.com/xitongsys/parquet-go/writer"
)

type userInfo struct {
	// UniqueID is UniqueID_DATE. Example: 1234567890_20220301. manually generated by this parser and is unique across all entries
	UniqueID                 string            `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	BuildID                  string            `parquet:"name=build_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	IP                       string            `parquet:"name=ip, type=BYTE_ARRAY, convertedtype=UTF8"`
	FileLocation             string            `parquet:"name=file_location, type=BYTE_ARRAY, convertedtype=UTF8"`
	Username                 string            `parquet:"name=username, type=BYTE_ARRAY, convertedtype=UTF8"`
	Country                  string            `parquet:"name=country, type=BYTE_ARRAY, convertedtype=UTF8"`
	ZipCode                  string            `parquet:"name=zip_code, type=BYTE_ARRAY, convertedtype=UTF8"`
	Location                 string            `parquet:"name=location, type=BYTE_ARRAY, convertedtype=UTF8"`
	HWID                     string            `parquet:"name=hwid, type=BYTE_ARRAY, convertedtype=UTF8"`
	CurrentLang              string            `parquet:"name=current_lang, type=BYTE_ARRAY, convertedtype=UTF8"`
	ScreenSize               string            `parquet:"name=screen_size, type=BYTE_ARRAY, convertedtype=UTF8"`
	TimeZone                 string            `parquet:"name=time_zone, type=BYTE_ARRAY, convertedtype=UTF8"`
	OS                       string            `parquet:"name=os, type=BYTE_ARRAY, convertedtype=UTF8"`
	UAC                      string            `parquet:"name=uac, type=BYTE_ARRAY, convertedtype=UTF8"`
	ProcessElevation         string            `parquet:"name=process_elevation, type=BYTE_ARRAY, convertedtype=UTF8"`
	Elevated                 bool              `parquet:"name=elevated, type=BOOLEAN"`
	LogDate                  int64             `parquet:"name=log_date, type=INT64, convertedtype=TIMESTAMP_MILLIS"`
	AvailableKeyboardLayouts []string          `parquet:"name=available_keyboard_layouts, type=MAP, convertedtype=LIST, valuetype=BYTE_ARRAY, valueconvertedtype=UTF8"`
	Hardwares                []string          `parquet:"name=hardwares, type=MAP, convertedtype=LIST, valuetype=BYTE_ARRAY, valueconvertedtype=UTF8"`
	Antiviruses              []string          `parquet:"name=antiviruses, type=MAP, convertedtype=LIST, valuetype=BYTE_ARRAY, valueconvertedtype=UTF8"`
	AdditionalFields         map[string]string `parquet:"name=additional_fields, type=MAP, convertedtype=MAP, keytype=BYTE_ARRAY, keyconvertedtype=UTF8, valuetype=BYTE_ARRAY, valueconvertedtype=UTF8"`
}

type passwordEntry struct {
	UniqueID    string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	URL         string `parquet:"name=url, type=BYTE_ARRAY, convertedtype=UTF8"`
	Username    string `parquet:"name=username, type=BYTE_ARRAY, convertedtype=UTF8"`
	Password    string `parquet:"name=password, type=BYTE_ARRAY, convertedtype=UTF8"`
	Application string `parquet:"name=application, type=BYTE_ARRAY, convertedtype=UTF8"`
}

type autofillEntry struct {
	UniqueID string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Key      string `parquet:"name=key, type=BYTE_ARRAY, convertedtype=UTF8"`
	Value    string `parquet:"name=value, type=BYTE_ARRAY, convertedtype=UTF8"`
}

type creditCardEntry struct {
	UniqueID string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Holder   string `parquet:"name=holder, type=BYTE_ARRAY, convertedtype=UTF8"`
	Type     string `parquet:"name=type, type=BYTE_ARRAY, convertedtype=UTF8"`
	Number   string `parquet:"name=number, type=BYTE_ARRAY, convertedtype=UTF8"`
	Expiry   string `parquet:"name=expiry, type=BYTE_ARRAY, convertedtype=UTF8"`
}

type installedSoftwareEntry struct {
	UniqueID string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	ID       int64  `parquet:"name=id, type=INT64"`
	Name     string `parquet:"name=name, type=BYTE_ARRAY, convertedtype=UTF8"`
	Version  string `parquet:"name=version, type=BYTE_ARRAY, convertedtype=UTF8"`
}

type processEntry struct {
	UniqueID string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	ID       int64  `parquet:"name=id, type=INT64"`
	Name     string `parquet:"name=name, type=BYTE_ARRAY, convertedtype=UTF8"`
	CmdLine  string `parquet:"name=cmdline, type=BYTE_ARRAY, convertedtype=UTF8"`
}

type cookieEntry struct {
	UniqueID   string `parquet:"name=unique_id, type=BYTE_ARRAY, convertedtype=UTF8"`
	Domain     string `parquet:"name=domain, type=BYTE_ARRAY, convertedtype=UTF8"`
	Flag       bool   `parquet:"name=flag, type=BOOLEAN"`
	Path       string `parquet:"name=path, type=BYTE_ARRAY, convertedtype=UTF8"`
	Secure     bool   `parquet:"name=secure, type=BOOLEAN"`
	Expiration int64  `parquet:"name=expiration, type=INT64"`
	Name       string `parquet:"name=name, type=BYTE_ARRAY, convertedtype=UTF8"`
	Value      string `parquet:"name=value, type=BYTE_ARRAY, convertedtype=UTF8"`
}

var (
	inputDir  = flag.String("input_dir", "", "Input folder path")
	outputDir = flag.String("output_dir", ".", "Output folder path")
)

func main() {
	// Parse command-line arguments
	flag.Parse()

	if *inputDir == "" {
		fmt.Println("Please provide the input folder path using -input flag.")
		os.Exit(1)
	}
	inputFolder := *inputDir
	outputFolder := *outputDir

	// Define slices to hold the data
	var userinfo userInfo
	var passwords []passwordEntry
	var autofills []autofillEntry
	// var creditCards []CreditCardEntry
	var installedSoftware []installedSoftwareEntry
	var processes []processEntry
	var cookies []cookieEntry

	var err error

	// Read UserInformation.txt
	userinfo, err = readUserInformation(filepath.Join(inputFolder, "UserInformation.txt"))
	if err != nil {
		fmt.Printf("Error reading UserInformation.txt: %v\n", err)
	}

	// read hwid from userInfo and if not present, generate a new one and apply
	if userinfo.HWID == "" {
		// TODO: log this
		userinfo.HWID = uuid.NewString()
	}
	// use the LogDate to generate the date format and form the unique id
	if userinfo.LogDate != 0 {
		t := time.Unix(userinfo.LogDate/1000, 0)
		userinfo.UniqueID = fmt.Sprintf("%s_%s", userinfo.HWID, t.Format("20060102"))
	} else {
		// if the date is not present, use the current date
		userinfo.UniqueID = fmt.Sprintf("%s_%s", userinfo.HWID, time.Now().Format("20060102"))
	}

	// now that we have the UniqueID, we can write it to the output folder
	err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("user_info_%s.parquet", userinfo.UniqueID)), &userinfo)
	if err != nil {
		fmt.Printf("Error writing user_info_%s.parquet: %v\n", userinfo.UniqueID, err)
	}

	// Read Passwords.txt
	passwords, err = readPasswords(filepath.Join(inputFolder, "Passwords.txt"), userinfo.UniqueID)
	if err != nil {
		fmt.Printf("Error reading Passwords.txt: %v\n", err)
	} else {
		// write the passwords to a file
		err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("passwords_%s.parquet", userinfo.UniqueID)), passwords)
		if err != nil {
			fmt.Printf("Error writing passwords_%s.parquet: %v\n", userinfo.UniqueID, err)
		}
	}

	// Read Autofills
	autofillsDir := filepath.Join(inputFolder, "Autofills")
	autofills, err = readAutofills(autofillsDir, userinfo.UniqueID)
	if err != nil {
		fmt.Printf("Error reading autofills: %v\n", err)
	} else {
		// write the autofills to a file
		err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("autofills_%s.parquet", userinfo.UniqueID)), autofills)
		if err != nil {
			fmt.Printf("Error writing autofills_%s.parquet: %v\n", userinfo.UniqueID, err)
		}
	}

	// Read InstalledSoftware.txt
	installedSoftware, err = readInstalledSoftware(filepath.Join(inputFolder, "InstalledSoftware.txt"), userinfo.UniqueID)
	if err != nil {
		fmt.Printf("Error reading InstalledSoftware.txt: %v\n", err)
	} else {
		// write the installed software to a file
		err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("installed_software_%s.parquet", userinfo.UniqueID)), installedSoftware)
		if err != nil {
			fmt.Printf("Error writing installed_software_%s.parquet: %v\n", userinfo.UniqueID, err)
		}
	}

	// Read ProcessList.txt
	processes, err = readProcesses(filepath.Join(inputFolder, "ProcessList.txt"), userinfo.UniqueID)
	if err != nil {
		fmt.Printf("Error reading ProcessList.txt: %v\n", err)
	} else {
		// write the processes to a file
		err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("processes_%s.parquet", userinfo.UniqueID)), processes)
		if err != nil {
			fmt.Printf("Error writing processes_%s.parquet: %v\n", userinfo.UniqueID, err)
		}
	}

	// Read Cookies
	cookiesDir := filepath.Join(inputFolder, "Cookies")
	cookies, err = readCookies(cookiesDir, userinfo.UniqueID)
	if err != nil {
		fmt.Printf("Error reading cookies: %v\n", err)
	} else {
		// write the cookies to a file
		err = writeParquetFile(filepath.Join(outputFolder, fmt.Sprintf("cookies_%s.parquet", userinfo.UniqueID)), cookies)
		if err != nil {
			fmt.Printf("Error writing cookies_%s.parquet: %v\n", userinfo.UniqueID, err)
		}
	}
}

func readUserInformation(filePath string) (userInfo, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return userInfo{}, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	userinfo := userInfo{
		AdditionalFields: make(map[string]string),
	}

	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "*") || strings.TrimSpace(line) == "" {
			continue
		}
		parts := strings.SplitN(line, ":", 2)
		if len(parts) != 2 {
			continue
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "Build ID":
			userinfo.BuildID = value
		case "IP":
			userinfo.IP = value
		case "FileLocation":
			userinfo.FileLocation = value
		case "UserName":
			userinfo.Username = value
		case "Country":
			userinfo.Country = value
		case "Zip Code":
			userinfo.ZipCode = value
		case "Location":
			userinfo.Location = value
		case "HWID":
			userinfo.HWID = value
		case "Current Language":
			userinfo.CurrentLang = value
		case "ScreenSize":
			userinfo.ScreenSize = value
		case "TimeZone":
			userinfo.TimeZone = value
		case "Operation System":
			userinfo.OS = value
		case "UAC":
			userinfo.UAC = value
		case "Process Elevation":
			userinfo.ProcessElevation = value
		case "Log date":
			if t, err := time.Parse("1/2/2006 3:04:05 PM", value); err != nil {
				log.Printf("Error parsing log date: %v\n", err)
				userinfo.LogDate = 0
			} else {
				userinfo.LogDate = t.UnixNano() / int64(time.Millisecond)
			}
		case "Available KeyboardLayouts":
			userinfo.AvailableKeyboardLayouts = strings.Split(value, "\n")
		case "Hardwares":
			userinfo.Hardwares = strings.Split(value, "\n")
		case "Anti-Viruses":
			userinfo.Antiviruses = strings.Split(value, "\n")
		default:
			userinfo.AdditionalFields[key] = value
		}
	}

	if err := scanner.Err(); err != nil {
		return userInfo{}, err
	}

	return userinfo, nil
}

func readPasswords(filePath string, hwid string) ([]passwordEntry, error) {
	var passwords []passwordEntry

	data, err := os.ReadFile(filePath)
	if err != nil {
		return passwords, err
	}

	entries := strings.Split(string(data), "===============")
	for _, entry := range entries {
		entry = strings.TrimSpace(entry)
		if entry == "" {
			continue
		}

		var passwordEntry passwordEntry
		lines := strings.Split(entry, "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" || strings.HasPrefix(line, "//") {
				line = strings.TrimPrefix(line, "//")
				line = strings.TrimSpace(line)
			}
			if line == "" {
				continue
			}
			parts := strings.SplitN(line, ": ", 2)
			if len(parts) != 2 {
				continue
			}
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])

			switch key {
			case "URL":
				passwordEntry.URL = value
			case "Username":
				passwordEntry.Username = value
			case "Password":
				passwordEntry.Password = value
			case "Application":
				passwordEntry.Application = value
			}
		}
		passwordEntry.UniqueID = hwid
		passwords = append(passwords, passwordEntry)
	}

	return passwords, nil
}
func readAutofills(dirPath string, hwid string) ([]autofillEntry, error) {
	var autofills []autofillEntry

	files, err := os.ReadDir(dirPath)
	if err != nil {
		return autofills, err
	}

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".txt") {
			continue
		}
		filePath := filepath.Join(dirPath, file.Name())
		fileAutofills, err := parseAutofillFile(filePath, hwid)
		if err != nil {
			fmt.Printf("Error parsing %s: %v\n", file.Name(), err)
			continue
		}
		autofills = append(autofills, fileAutofills...)
	}

	return autofills, nil
}
func parseAutofillFile(filePath string, hwid string) ([]autofillEntry, error) {
	var autofills []autofillEntry

	file, err := os.Open(filePath)
	if err != nil {
		return autofills, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var entry autofillEntry
	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			if entry.Key != "" {
				entry.UniqueID = hwid
				autofills = append(autofills, entry)
				entry = autofillEntry{}
			}
			continue
		}

		parts := strings.SplitN(line, ": ", 2)
		if len(parts) != 2 {
			continue
		}
		key := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch key {
		case "Name":
			entry.Key = value
		case "Value":
			entry.Value = value
		}
	}

	if entry.Key != "" {
		entry.UniqueID = hwid
		autofills = append(autofills, entry)
	}

	if err := scanner.Err(); err != nil {
		return autofills, err
	}

	return autofills, nil
}

func readInstalledSoftware(filePath string, hwid string) ([]installedSoftwareEntry, error) {
	var software []installedSoftwareEntry

	file, err := os.Open(filePath)
	if err != nil {
		return software, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var id int64

	for scanner.Scan() {
		line := scanner.Text()
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "*") {
			continue
		}

		// Example line: "1) 7-Zip 24.03 [24.03]"
		// Split by the first occurrence of '[' to separate the name and version
		parts := strings.SplitN(line, "[", 2)
		if len(parts) != 2 {
			continue
		}

		// Extract name and version
		name := strings.TrimSpace(parts[0])
		name = strings.TrimSuffix(name, " ")                      // Remove trailing space before the '['
		name = strings.TrimSpace(strings.SplitN(name, " ", 2)[1]) // Remove the leading number and parenthesis

		version := strings.TrimSuffix(parts[1], "]")

		entry := installedSoftwareEntry{
			UniqueID: hwid,
			ID:       id,
			Name:     name,
			Version:  version,
		}
		software = append(software, entry)
		id++
	}

	if err := scanner.Err(); err != nil {
		return software, err
	}

	return software, nil
}
func readProcesses(filePath string, hwid string) ([]processEntry, error) {
	var processes []processEntry

	data, err := os.ReadFile(filePath)
	if err != nil {
		return processes, err
	}

	entries := strings.Split(string(data), "===============")
	for _, entry := range entries {
		entry = strings.TrimSpace(entry)
		if entry == "" {
			continue
		}

		parts := strings.Split(entry, ",")
		var process processEntry
		for _, part := range parts {
			part = strings.TrimSpace(part)
			keyValue := strings.SplitN(part, ": ", 2)
			if len(keyValue) != 2 {
				continue
			}
			key := keyValue[0]
			value := keyValue[1]
			switch key {
			case "ID":
				fmt.Sscanf(value, "%d", &process.ID)
			case "Name":
				process.Name = value
			case "CommandLine":
				process.CmdLine = value
			}
		}
		process.UniqueID = hwid
		processes = append(processes, process)
	}

	return processes, nil
}
func readCookies(dirPath string, hwid string) ([]cookieEntry, error) {
	var cookies []cookieEntry

	files, err := os.ReadDir(dirPath)
	if err != nil {
		return cookies, err
	}

	for _, file := range files {
		if file.IsDir() || !strings.HasSuffix(file.Name(), ".txt") {
			continue
		}
		filePath := filepath.Join(dirPath, file.Name())
		fileCookies, err := parseCookieFile(filePath, hwid)
		if err != nil {
			fmt.Printf("Error parsing %s: %v\n", file.Name(), err)
			continue
		}
		cookies = append(cookies, fileCookies...)
	}

	return cookies, nil
}

func parseCookieFile(filePath string, hwid string) ([]cookieEntry, error) {
	var cookies []cookieEntry

	file, err := os.Open(filePath)
	if err != nil {
		return cookies, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		parts := strings.Split(line, "\t")
		if len(parts) != 7 {
			continue
		}

		flag := parts[1] == "TRUE"
		secure := parts[3] == "TRUE"
		expiration, _ := strconv.ParseInt(parts[4], 10, 64)

		entry := cookieEntry{
			UniqueID:   hwid,
			Domain:     parts[0],
			Flag:       flag,
			Path:       parts[2],
			Secure:     secure,
			Expiration: expiration,
			Name:       parts[5],
			Value:      parts[6],
		}
		cookies = append(cookies, entry)
	}

	if err := scanner.Err(); err != nil {
		return cookies, err
	}

	return cookies, nil

}

func writeParquetFile(fileName string, data interface{}) error {

	fw, err := local.NewLocalFileWriter(fileName)
	if err != nil {

		return err
	}

	pw, err := writer.NewParquetWriter(fw, data, 4)
	if err != nil {

		return err
	}
	pw.RowGroupSize = 128 * 1024 * 1024 //128M
	pw.CompressionType = parquet.CompressionCodec_SNAPPY
	switch v := data.(type) {
	case *userInfo:
		if err = pw.Write(v); err != nil {
			return err
		}
	case []passwordEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	case []autofillEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	case []creditCardEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	case []installedSoftwareEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	case []processEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	case []cookieEntry:
		for _, item := range v {
			if err = pw.Write(item); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported data type: %T", v)
	}

	if err = pw.WriteStop(); err != nil {
		return err
	}

	return nil
}
